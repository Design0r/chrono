// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: events.sql

package repo

import (
	"context"
	"time"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (name, user_id, scheduled_at, state)
VALUES (?, ?, ?, ?)
RETURNING id, scheduled_at, name, state, created_at, edited_at, user_id
`

type CreateEventParams struct {
	Name        string    `json:"name"`
	UserID      int64     `json:"user_id"`
	ScheduledAt time.Time `json:"scheduled_at"`
	State       string    `json:"state"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, createEvent,
		arg.Name,
		arg.UserID,
		arg.ScheduledAt,
		arg.State,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.ScheduledAt,
		&i.Name,
		&i.State,
		&i.CreatedAt,
		&i.EditedAt,
		&i.UserID,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :one
DELETE from events
WHERE id = ?
RETURNING id, scheduled_at, name, state, created_at, edited_at, user_id
`

func (q *Queries) DeleteEvent(ctx context.Context, id int64) (Event, error) {
	row := q.db.QueryRowContext(ctx, deleteEvent, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.ScheduledAt,
		&i.Name,
		&i.State,
		&i.CreatedAt,
		&i.EditedAt,
		&i.UserID,
	)
	return i, err
}

const getAcceptedEventsForMonth = `-- name: GetAcceptedEventsForMonth :many
SELECT e.id, scheduled_at, name, state, e.created_at, e.edited_at, user_id, u.id, username, email, password, vacation_days, is_superuser, u.created_at, u.edited_at, color
FROM events e
JOIN users u ON e.user_id = u.id
WHERE scheduled_at >= ? AND scheduled_at < ?
AND state = "accepted"
`

type GetAcceptedEventsForMonthParams struct {
	ScheduledAt   time.Time `json:"scheduled_at"`
	ScheduledAt_2 time.Time `json:"scheduled_at_2"`
}

type GetAcceptedEventsForMonthRow struct {
	ID           int64     `json:"id"`
	ScheduledAt  time.Time `json:"scheduled_at"`
	Name         string    `json:"name"`
	State        string    `json:"state"`
	CreatedAt    time.Time `json:"created_at"`
	EditedAt     time.Time `json:"edited_at"`
	UserID       int64     `json:"user_id"`
	ID_2         int64     `json:"id_2"`
	Username     string    `json:"username"`
	Email        string    `json:"email"`
	Password     string    `json:"password"`
	VacationDays int64     `json:"vacation_days"`
	IsSuperuser  bool      `json:"is_superuser"`
	CreatedAt_2  time.Time `json:"created_at_2"`
	EditedAt_2   time.Time `json:"edited_at_2"`
	Color        string    `json:"color"`
}

func (q *Queries) GetAcceptedEventsForMonth(ctx context.Context, arg GetAcceptedEventsForMonthParams) ([]GetAcceptedEventsForMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, getAcceptedEventsForMonth, arg.ScheduledAt, arg.ScheduledAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAcceptedEventsForMonthRow
	for rows.Next() {
		var i GetAcceptedEventsForMonthRow
		if err := rows.Scan(
			&i.ID,
			&i.ScheduledAt,
			&i.Name,
			&i.State,
			&i.CreatedAt,
			&i.EditedAt,
			&i.UserID,
			&i.ID_2,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.VacationDays,
			&i.IsSuperuser,
			&i.CreatedAt_2,
			&i.EditedAt_2,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConflictingEventUsers = `-- name: GetConflictingEventUsers :many
SELECT DISTINCT u.id, u.username, u.email, u.password, u.vacation_days, u.is_superuser, u.created_at, u.edited_at, u.color FROM events e
JOIN users u on e.user_id = u.id
WHERE u.id != ? 
AND e.scheduled_at >= ?
AND e.scheduled_at <= ?
`

type GetConflictingEventUsersParams struct {
	ID            int64     `json:"id"`
	ScheduledAt   time.Time `json:"scheduled_at"`
	ScheduledAt_2 time.Time `json:"scheduled_at_2"`
}

func (q *Queries) GetConflictingEventUsers(ctx context.Context, arg GetConflictingEventUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getConflictingEventUsers, arg.ID, arg.ScheduledAt, arg.ScheduledAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.VacationDays,
			&i.IsSuperuser,
			&i.CreatedAt,
			&i.EditedAt,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsForDay = `-- name: GetEventsForDay :many
SELECT id, scheduled_at, name, state, created_at, edited_at, user_id FROM events 
WHERE Date(scheduled_at) = ?
`

func (q *Queries) GetEventsForDay(ctx context.Context, scheduledAt time.Time) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getEventsForDay, scheduledAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.ScheduledAt,
			&i.Name,
			&i.State,
			&i.CreatedAt,
			&i.EditedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsForMonth = `-- name: GetEventsForMonth :many
SELECT e.id, scheduled_at, name, state, e.created_at, e.edited_at, user_id, u.id, username, email, password, vacation_days, is_superuser, u.created_at, u.edited_at, color
FROM events e
JOIN users u ON e.user_id = u.id
WHERE scheduled_at >= ? AND scheduled_at < ?
`

type GetEventsForMonthParams struct {
	ScheduledAt   time.Time `json:"scheduled_at"`
	ScheduledAt_2 time.Time `json:"scheduled_at_2"`
}

type GetEventsForMonthRow struct {
	ID           int64     `json:"id"`
	ScheduledAt  time.Time `json:"scheduled_at"`
	Name         string    `json:"name"`
	State        string    `json:"state"`
	CreatedAt    time.Time `json:"created_at"`
	EditedAt     time.Time `json:"edited_at"`
	UserID       int64     `json:"user_id"`
	ID_2         int64     `json:"id_2"`
	Username     string    `json:"username"`
	Email        string    `json:"email"`
	Password     string    `json:"password"`
	VacationDays int64     `json:"vacation_days"`
	IsSuperuser  bool      `json:"is_superuser"`
	CreatedAt_2  time.Time `json:"created_at_2"`
	EditedAt_2   time.Time `json:"edited_at_2"`
	Color        string    `json:"color"`
}

func (q *Queries) GetEventsForMonth(ctx context.Context, arg GetEventsForMonthParams) ([]GetEventsForMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, getEventsForMonth, arg.ScheduledAt, arg.ScheduledAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsForMonthRow
	for rows.Next() {
		var i GetEventsForMonthRow
		if err := rows.Scan(
			&i.ID,
			&i.ScheduledAt,
			&i.Name,
			&i.State,
			&i.CreatedAt,
			&i.EditedAt,
			&i.UserID,
			&i.ID_2,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.VacationDays,
			&i.IsSuperuser,
			&i.CreatedAt_2,
			&i.EditedAt_2,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingEventsForYear = `-- name: GetPendingEventsForYear :one
SELECT Count(id) from events
WHERE state = "pending"
AND scheduled_at >= ?
AND scheduled_at < ?
AND user_id = ?
`

type GetPendingEventsForYearParams struct {
	ScheduledAt   time.Time `json:"scheduled_at"`
	ScheduledAt_2 time.Time `json:"scheduled_at_2"`
	UserID        int64     `json:"user_id"`
}

func (q *Queries) GetPendingEventsForYear(ctx context.Context, arg GetPendingEventsForYearParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPendingEventsForYear, arg.ScheduledAt, arg.ScheduledAt_2, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserPendingEvents = `-- name: GetUserPendingEvents :many
SELECT id, scheduled_at, name, state, created_at, edited_at, user_id FROM events
WHERE user_id = ?
AND state = "pending"
`

func (q *Queries) GetUserPendingEvents(ctx context.Context, userID int64) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getUserPendingEvents, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.ScheduledAt,
			&i.Name,
			&i.State,
			&i.CreatedAt,
			&i.EditedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVacationCountForUser = `-- name: GetVacationCountForUser :one
SELECT 
  SUM(
    CASE
      WHEN name = 'urlaub'          THEN 1
      WHEN name = 'urlaub halbtags' THEN 0.5
      ELSE 0
    END
  ) 
FROM events
WHERE user_id = ?
  AND scheduled_at >= ?
  AND scheduled_at < ?
  AND name IN ('urlaub', 'urlaub halbtags')
  AND state = 'accepted'
`

type GetVacationCountForUserParams struct {
	UserID        int64     `json:"user_id"`
	ScheduledAt   time.Time `json:"scheduled_at"`
	ScheduledAt_2 time.Time `json:"scheduled_at_2"`
}

func (q *Queries) GetVacationCountForUser(ctx context.Context, arg GetVacationCountForUserParams) (*float64, error) {
	row := q.db.QueryRowContext(ctx, getVacationCountForUser, arg.UserID, arg.ScheduledAt, arg.ScheduledAt_2)
	var sum *float64
	err := row.Scan(&sum)
	return sum, err
}

const updateEventState = `-- name: UpdateEventState :one
UPDATE events
SET state = ?,
edited_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, scheduled_at, name, state, created_at, edited_at, user_id
`

type UpdateEventStateParams struct {
	State string `json:"state"`
	ID    int64  `json:"id"`
}

func (q *Queries) UpdateEventState(ctx context.Context, arg UpdateEventStateParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, updateEventState, arg.State, arg.ID)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.ScheduledAt,
		&i.Name,
		&i.State,
		&i.CreatedAt,
		&i.EditedAt,
		&i.UserID,
	)
	return i, err
}

const updateEventsRange = `-- name: UpdateEventsRange :exec
UPDATE events
SET state = ?, 
edited_at = CURRENT_TIMESTAMP
WHERE user_id = ? 
AND scheduled_at >= ?
AND scheduled_at <= ?
`

type UpdateEventsRangeParams struct {
	State         string    `json:"state"`
	UserID        int64     `json:"user_id"`
	ScheduledAt   time.Time `json:"scheduled_at"`
	ScheduledAt_2 time.Time `json:"scheduled_at_2"`
}

func (q *Queries) UpdateEventsRange(ctx context.Context, arg UpdateEventsRangeParams) error {
	_, err := q.db.ExecContext(ctx, updateEventsRange,
		arg.State,
		arg.UserID,
		arg.ScheduledAt,
		arg.ScheduledAt_2,
	)
	return err
}
