// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: requests.sql

package repo

import (
	"context"
	"time"
)

const CreateRequest = `-- name: CreateRequest :one
INSERT INTO requests (message, state, user_id, event_id)
VALUES (?, ?, ?, ?)
RETURNING id, message, state, created_at, edited_at, user_id, edited_by, event_id
`

type CreateRequestParams struct {
	Message *string `json:"message"`
	State   string  `json:"state"`
	UserID  int64   `json:"user_id"`
	EventID int64   `json:"event_id"`
}

func (q *Queries) CreateRequest(ctx context.Context, arg CreateRequestParams) (Request, error) {
	row := q.db.QueryRowContext(ctx, CreateRequest,
		arg.Message,
		arg.State,
		arg.UserID,
		arg.EventID,
	)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.Message,
		&i.State,
		&i.CreatedAt,
		&i.EditedAt,
		&i.UserID,
		&i.EditedBy,
		&i.EventID,
	)
	return i, err
}

const GetEventNameFromRequest = `-- name: GetEventNameFromRequest :one
SELECT e.name FROM requests r
JOIN events e on r.event_id = e.id
WHERE r.id = ?
`

func (q *Queries) GetEventNameFromRequest(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRowContext(ctx, GetEventNameFromRequest, id)
	var name string
	err := row.Scan(&name)
	return name, err
}

const GetPendingRequests = `-- name: GetPendingRequests :many
SELECT r.id, message, r.state, r.created_at, r.edited_at, r.user_id, edited_by, event_id, u.id, username, email, password, vacation_days, is_superuser, u.created_at, u.edited_at, color, role, enabled, e.id, scheduled_at, name, e.state, e.created_at, e.edited_at, e.user_id FROM requests r
JOIN users u ON r.user_id = u.id
JOIN events e ON r.event_id = e.id
WHERE r.state = "pending"
ORDER BY r.user_id, e.scheduled_at
`

type GetPendingRequestsRow struct {
	ID           int64     `json:"id"`
	Message      *string   `json:"message"`
	State        string    `json:"state"`
	CreatedAt    time.Time `json:"created_at"`
	EditedAt     time.Time `json:"edited_at"`
	UserID       int64     `json:"user_id"`
	EditedBy     *int64    `json:"edited_by"`
	EventID      int64     `json:"event_id"`
	ID_2         int64     `json:"id_2"`
	Username     string    `json:"username"`
	Email        string    `json:"email"`
	Password     string    `json:"password"`
	VacationDays int64     `json:"vacation_days"`
	IsSuperuser  bool      `json:"is_superuser"`
	CreatedAt_2  time.Time `json:"created_at_2"`
	EditedAt_2   time.Time `json:"edited_at_2"`
	Color        string    `json:"color"`
	Role         string    `json:"role"`
	Enabled      bool      `json:"enabled"`
	ID_3         int64     `json:"id_3"`
	ScheduledAt  time.Time `json:"scheduled_at"`
	Name         string    `json:"name"`
	State_2      string    `json:"state_2"`
	CreatedAt_3  time.Time `json:"created_at_3"`
	EditedAt_3   time.Time `json:"edited_at_3"`
	UserID_2     int64     `json:"user_id_2"`
}

func (q *Queries) GetPendingRequests(ctx context.Context) ([]GetPendingRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetPendingRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingRequestsRow
	for rows.Next() {
		var i GetPendingRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.Message,
			&i.State,
			&i.CreatedAt,
			&i.EditedAt,
			&i.UserID,
			&i.EditedBy,
			&i.EventID,
			&i.ID_2,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.VacationDays,
			&i.IsSuperuser,
			&i.CreatedAt_2,
			&i.EditedAt_2,
			&i.Color,
			&i.Role,
			&i.Enabled,
			&i.ID_3,
			&i.ScheduledAt,
			&i.Name,
			&i.State_2,
			&i.CreatedAt_3,
			&i.EditedAt_3,
			&i.UserID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRequestRange = `-- name: GetRequestRange :many
SELECT r.id, r.message, r.state, r.created_at, r.edited_at, r.user_id, r.edited_by, r.event_id FROM requests r
JOIN users u ON r.user_id = u.id
JOIN events e ON r.event_id = e.id
WHERE r.user_id = ?
AND e.scheduled_at >= ?
AND e.scheduled_at <= ?
ORDER BY e.scheduled_at
`

type GetRequestRangeParams struct {
	UserID        int64     `json:"user_id"`
	ScheduledAt   time.Time `json:"scheduled_at"`
	ScheduledAt_2 time.Time `json:"scheduled_at_2"`
}

func (q *Queries) GetRequestRange(ctx context.Context, arg GetRequestRangeParams) ([]Request, error) {
	rows, err := q.db.QueryContext(ctx, GetRequestRange, arg.UserID, arg.ScheduledAt, arg.ScheduledAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Request
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.Message,
			&i.State,
			&i.CreatedAt,
			&i.EditedAt,
			&i.UserID,
			&i.EditedBy,
			&i.EventID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateRequest = `-- name: UpdateRequest :one
UPDATE requests
SET message = ?,
state = ?,
edited_by = ?,
event_id = ?,
edited_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, message, state, created_at, edited_at, user_id, edited_by, event_id
`

type UpdateRequestParams struct {
	Message  *string `json:"message"`
	State    string  `json:"state"`
	EditedBy *int64  `json:"edited_by"`
	EventID  int64   `json:"event_id"`
	ID       int64   `json:"id"`
}

func (q *Queries) UpdateRequest(ctx context.Context, arg UpdateRequestParams) (Request, error) {
	row := q.db.QueryRowContext(ctx, UpdateRequest,
		arg.Message,
		arg.State,
		arg.EditedBy,
		arg.EventID,
		arg.ID,
	)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.Message,
		&i.State,
		&i.CreatedAt,
		&i.EditedAt,
		&i.UserID,
		&i.EditedBy,
		&i.EventID,
	)
	return i, err
}

const UpdateRequestStateRange = `-- name: UpdateRequestStateRange :one
UPDATE requests
SET state = ?,
    edited_by = ?,
    edited_at = CURRENT_TIMESTAMP
WHERE requests.user_id = ?
AND event_id IN (
    SELECT e.id
    FROM events e
    WHERE e.scheduled_at >= ?
      AND e.scheduled_at <= ?
  )
RETURNING requests.id
`

type UpdateRequestStateRangeParams struct {
	State         string    `json:"state"`
	EditedBy      *int64    `json:"edited_by"`
	UserID        int64     `json:"user_id"`
	ScheduledAt   time.Time `json:"scheduled_at"`
	ScheduledAt_2 time.Time `json:"scheduled_at_2"`
}

func (q *Queries) UpdateRequestStateRange(ctx context.Context, arg UpdateRequestStateRangeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, UpdateRequestStateRange,
		arg.State,
		arg.EditedBy,
		arg.UserID,
		arg.ScheduledAt,
		arg.ScheduledAt_2,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
